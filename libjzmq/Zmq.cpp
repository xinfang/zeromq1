/*
    Copyright (c) 2007-2009 FastMQ Inc.

    This file is part of 0MQ.

    0MQ is free software; you can redistribute it and/or modify it under
    the terms of the Lesser GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    0MQ is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    Lesser GNU General Public License for more details.

    You should have received a copy of the Lesser GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

//  The header file generated by JNI from Zmq.java source file.
#include "org_zmq_Zmq.h"
#include "org_zmq_Zmq_InboundData.h"

#include <stdio.h>

#include <zmq.hpp>
#include <zmq/err.hpp>

static jfieldID context_fid = NULL;

struct context_t
{
    //  Cache for JNI static objects.
    jclass inbound_data_class;
    jfieldID queue_fid;
    jfieldID type_fid;
    jfieldID message_fid;

    //  0MQ infrastructure.
    zmq::locator_t *locator;
    zmq::dispatcher_t *dispatcher;
    zmq::i_thread *io_thread;
    zmq::api_thread_t *api_thread;
};

JNIEXPORT void JNICALL Java_org_zmq_Zmq_construct (JNIEnv *env, jobject obj,
    jstring host)
{
    //  Cache context field ID.
    jclass cls = env->GetObjectClass (obj);
    context_fid = env->GetFieldID (cls, "context", "J");
    zmq_assert (context_fid);

    //  Get the hostname.
    zmq_assert (host);
    char *c_host = (char*) env->GetStringUTFChars (host, 0);
    zmq_assert (c_host);

    //  Create the context.
    context_t *context = new context_t;
    zmq_assert (context);
    context->dispatcher = new zmq::dispatcher_t (2);
    zmq_assert (context->dispatcher);
    context->locator = new zmq::locator_t (c_host);
    zmq_assert (context->locator);
    context->io_thread = zmq::io_thread_t::create (context->dispatcher);
    zmq_assert (context->io_thread);
    context->api_thread = zmq::api_thread_t::create (context->dispatcher,
        context->locator);
    zmq_assert (context->api_thread);

    //  Cache zmq.org.Zmq.InboundData class.
    jclass idc = env->FindClass ("org/zmq/Zmq$InboundData");
    zmq_assert (idc);
    context->inbound_data_class = (jclass) env->NewGlobalRef (idc);
    zmq_assert (context->inbound_data_class);
    env->DeleteLocalRef (idc);

    //  Cache fieldIDs for InboundData member variables.
    context->queue_fid = env->GetFieldID (context->inbound_data_class,
        "queue", "I");
    zmq_assert (context->queue_fid);
    context->type_fid = env->GetFieldID (context->inbound_data_class,
        "type", "I");
    zmq_assert (context->type_fid);
    context->message_fid = env->GetFieldID (context->inbound_data_class,
        "message", "[B");
    zmq_assert (context->message_fid);

    //  Clean-up.
    env->ReleaseStringUTFChars (host, c_host);

    //  Set the context.
    env->SetLongField (obj, context_fid, (jlong) context);
}

JNIEXPORT void JNICALL Java_org_zmq_Zmq_finalize (JNIEnv *env, jobject obj)
{
    //  Get the context.
    context_t *context = (context_t*) env->GetLongField (obj, context_fid);
    zmq_assert (context);

    //  Free JNI cached JNI objects.
    env->DeleteGlobalRef ((jobject) context->inbound_data_class);

    //  Deallocate the 0MQ infrastructure.
    delete context->locator;
    delete context->dispatcher;

    delete context;
}

JNIEXPORT void JNICALL Java_org_zmq_Zmq_mask (JNIEnv *env, jobject obj,
    int notifications)
{
    //  Get the context.
    context_t *context = (context_t*) env->GetLongField (obj, context_fid);
    zmq_assert (context);
    
    //  Forward the call.
    context->api_thread->mask (notifications);
}

JNIEXPORT jint JNICALL Java_org_zmq_Zmq_createExchange (JNIEnv *env, jobject obj,
    jstring name, jint scope, jstring location, jint style)
{
    //  Get the context.
    context_t *context = (context_t*) env->GetLongField (obj, context_fid);
    zmq_assert (context);

    //  Get the exchange name.
    zmq_assert (name);
    char *c_name = (char*) env->GetStringUTFChars (name, 0);
    zmq_assert (c_name);

    //  Get the location.
    char *c_location = NULL;
    if (location)
        c_location = (char*) env->GetStringUTFChars (location, 0);

    //  Forward the call.
    jint eid = context->api_thread->create_exchange (c_name,
        (zmq::scope_t) scope, c_location, context->io_thread, 1,
        &context->io_thread, (zmq::style_t) style);

    //  Clean-up.
    env->ReleaseStringUTFChars (name, c_name);
    if (c_location)
        env->ReleaseStringUTFChars (location, c_location);

    return eid;
}

JNIEXPORT jint JNICALL Java_org_zmq_Zmq_createQueue (JNIEnv *env, jobject obj,
    jstring name, jint scope, jstring location, jlong hwm, jlong lwm, 
    jlong swap)
{
    //  Get the context.
    context_t *context = (context_t*) env->GetLongField (obj, context_fid);
    zmq_assert (context);

    //  Get the queue name.
    zmq_assert (name);
    char *c_name = (char*) env->GetStringUTFChars (name, 0);
    zmq_assert (c_name);

    //  Get NIC name.
    char *c_location = NULL;
    if (location)
        c_location = (char*) env->GetStringUTFChars (location, 0);

    //  Forward the call.
    jint qid = context->api_thread->create_queue (c_name, (zmq::scope_t) scope,
        c_location, context->io_thread, 1, &context->io_thread,
        (int64_t) hwm, (int64_t) lwm, (int64_t) swap);

    //  Clean-up.
    env->ReleaseStringUTFChars (name, c_name);
    if (c_location)
        env->ReleaseStringUTFChars (location, c_location);

    return qid;
}

JNIEXPORT void JNICALL Java_org_zmq_Zmq_bind (JNIEnv *env, jobject obj,
    jstring exchangeName, jstring queueName, jstring exchangeOptions,
    jstring queueOptions)
{
    //  Get the context.
    context_t *context = (context_t*) env->GetLongField (obj, context_fid);
    zmq_assert (context);

    //  Get the exchange name.
    zmq_assert (exchangeName);
    char *c_exchange_name = (char*) env->GetStringUTFChars (exchangeName, 0);
    zmq_assert (c_exchange_name);

    //  Get the queue name.
    zmq_assert (queueName);
    char *c_queue_name = (char*) env->GetStringUTFChars (queueName, 0);
    zmq_assert (c_queue_name);

    //  Get exchange options.
    char *c_exchange_options = NULL;
    if (exchangeOptions)
        c_exchange_options = (char*) env->GetStringUTFChars (
            exchangeOptions, 0);

    //  Get queue options.
    
    char *c_queue_options = NULL;
    if (queueOptions)
        c_queue_options = (char*) env->GetStringUTFChars (queueOptions, 0);

    //  Forward the call.
    context->api_thread->bind (c_exchange_name, c_queue_name,
        context->io_thread, context->io_thread, c_exchange_options,
        c_queue_options);

    //  Clean-up.
    env->ReleaseStringUTFChars (exchangeName, c_exchange_name);
    env->ReleaseStringUTFChars (queueName, c_queue_name);
    if (c_exchange_options)
        env->ReleaseStringUTFChars (exchangeOptions, c_exchange_options);
    if (c_queue_options)
        env->ReleaseStringUTFChars (queueOptions, c_queue_options);
}

JNIEXPORT jboolean JNICALL Java_org_zmq_Zmq_send (JNIEnv *env, jobject obj,
    jint exchange, jbyteArray message, jboolean block)
{
    //  Get the context.
    context_t *context = (context_t*) env->GetLongField (obj, context_fid);
    zmq_assert (context);

    //  Get the data from the bytearray.
    jsize size = env->GetArrayLength (message); 
    jbyte *data = env->GetByteArrayElements (message, 0);

    //  Create the message.
    zmq::message_t msg (size);
    memcpy (msg.data (), data, size);

    //  Release the bytearray.
    env->ReleaseByteArrayElements (message, data, 0);

    //  Send the message.
    return (jboolean) context->api_thread->send (exchange, msg, (bool) block);
}

JNIEXPORT jobject JNICALL Java_org_zmq_Zmq_receive (JNIEnv *env, jobject obj,
    jboolean block)
{
    //  Get the context.
    context_t *context = (context_t*) env->GetLongField (obj, context_fid);
    zmq_assert (context);

    //  Allocate new InboundData object; no constructor is called!
    //  We're doing the allocation before the receive so that delivery of
    //  the message is not slowed down by the allocation.
    jobject result = env->AllocObject (context->inbound_data_class);
    zmq_assert (result);

    //  Get new message.
    zmq::message_t msg;
    int qid = context->api_thread->receive (&msg, (bool) block);

    //  Fill in the InboundData object.
    env->SetIntField (result, context->queue_fid, (jint) qid);
    env->SetIntField (result, context->type_fid, (jint) msg.type ());
    jbyteArray data = env->NewByteArray (msg.size ());
    zmq_assert (data);
    env->SetByteArrayRegion (data, 0, msg.size (), (jbyte*) msg.data ());
    env->SetObjectField (result, context->message_fid, data);
    env->DeleteLocalRef (data);

    return result;
}
